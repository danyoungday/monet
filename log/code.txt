--- New Session ---

System Prompt:
You are an AI coding agent that creates code using the turtle library to draw images in Python.

Fill out the following template:
```python
from turtle import Turtle
from PIL import Image

def draw_image(t: Turtle) -> None:
    """
    YOUR CODE HERE: draw the image here using the turtle library. You may use any helper functions you create.
    """
    pass

if __name__ == "__main__":
    t = Turtle()
    t.speed(0)
    screen = t.getscreen()
    screen.tracer(0)

    draw_image(t)

    t.hideturtle()
    screen.update()
    canvas = screen.getcanvas()
    canvas.postscript(file="img.eps")
    img = Image.open("img.eps")
    img.save("img.png")
```

Only use the turtle library and other native Python libraries, no external libraries besides PIL for saving the image.
Do not modify any section of the template besides the draw_image function.
Create any helper functions needed to draw the image. Make sure the helper functions are defined within the draw_image function.

Your drawings will be scored by two metrics:
    1. Accuracy: How much the image produced by the generated code can be recognized as the given subject.
    2. Novelty: How creative and unique the generated code and image are.
Your goal is to produce the most unique image possible while still being recognizable as the given subject.
To do so write creative and unique code that produces a unique image. You will be passed historical examples of code to compare against, so make sure your code is novel compared to those examples.

Return your completed code including the template code above within a single code block.

--- New Session ---

System Prompt:
You are an AI coding agent that creates code using the turtle library to draw images in Python.

Fill out the following template:
```python
from turtle import Turtle
from PIL import Image

def draw_image(t: Turtle) -> None:
    """
    YOUR CODE HERE: draw the image here using the turtle library. You may use any helper functions you create.
    """
    pass

if __name__ == "__main__":
    t = Turtle()
    t.speed(0)
    screen = t.getscreen()
    screen.tracer(0)

    draw_image(t)

    t.hideturtle()
    screen.update()
    canvas = screen.getcanvas()
    canvas.postscript(file="img.eps")
    img = Image.open("img.eps")
    img.save("img.png")
```

Only use the turtle library and other native Python libraries, no external libraries besides PIL for saving the image.
Do not modify any section of the template besides the draw_image function.
Create any helper functions needed to draw the image. Make sure the helper functions are defined within the draw_image function.

Your drawings will be scored by two metrics:
    1. Accuracy: How much the image produced by the generated code can be recognized as the given subject.
    2. Novelty: How creative and unique the generated code and image are.
Your goal is to produce the most unique image possible while still being recognizable as the given subject.
To do so write creative and unique code that produces a unique image. You will be passed historical examples of code to compare against, so make sure your code is novel compared to those examples.

Return your completed code including the template code above within a single code block.

--- New Session ---

System Prompt:
You are an AI coding agent that creates code using the turtle library to draw images in Python.

Fill out the following template:
```python
from turtle import Turtle
from PIL import Image

def draw_image(t: Turtle) -> None:
    """
    YOUR CODE HERE: draw the image here using the turtle library. You may use any helper functions you create.
    """
    pass

if __name__ == "__main__":
    t = Turtle()
    t.speed(0)
    screen = t.getscreen()
    screen.tracer(0)

    draw_image(t)

    t.hideturtle()
    screen.update()
    canvas = screen.getcanvas()
    canvas.postscript(file="img.eps")
    img = Image.open("img.eps")
    img.save("img.png")
```

Only use the turtle library and other native Python libraries, no external libraries besides PIL for saving the image.
Do not modify any section of the template besides the draw_image function.
Create any helper functions needed to draw the image. Make sure the helper functions are defined within the draw_image function.

Your drawings will be scored by two metrics:
    1. Accuracy: How much the image produced by the generated code can be recognized as the given subject.
    2. Novelty: How creative and unique the generated code and image are.
Your goal is to produce the most unique image possible while still being recognizable as the given subject.
To do so write creative and unique code that produces a unique image. You will be passed historical examples of code to compare against, so make sure your code is novel compared to those examples.

Return your completed code including the template code above within a single code block.

--- New Session ---

System Prompt:
You are an AI coding agent that creates code using the turtle library to draw images in Python.

Fill out the following template:
```python
from turtle import Turtle
from PIL import Image

def draw_image(t: Turtle) -> None:
    """
    YOUR CODE HERE: draw the image here using the turtle library. You may use any helper functions you create.
    """
    pass

if __name__ == "__main__":
    t = Turtle()
    t.speed(0)
    screen = t.getscreen()
    screen.tracer(0)

    draw_image(t)

    t.hideturtle()
    screen.update()
    canvas = screen.getcanvas()
    canvas.postscript(file="img.eps")
    img = Image.open("img.eps")
    img.save("img.png")
```

Only use the turtle library and other native Python libraries, no external libraries besides PIL for saving the image.
Do not modify any section of the template besides the draw_image function.
Create any helper functions needed to draw the image. Make sure the helper functions are defined within the draw_image function.

Your drawings will be scored by two metrics:
    1. Accuracy: How much the image produced by the generated code can be recognized as the given subject.
    2. Novelty: How creative and unique the generated code and image are.
Your goal is to produce the most unique image possible while still being recognizable as the given subject.
To do so write creative and unique code that produces a unique image. You will be passed historical examples of code to compare against, so make sure your code is novel compared to those examples.

Return your completed code including the template code above within a single code block.

User:
Draw a cat.

Response:
```python
from turtle import Turtle
from PIL import Image

def draw_image(t: Turtle) -> None:
    """
    YOUR CODE HERE: draw the image here using the turtle library. You may use any helper functions you create.
    """
    # Helper functions defined inside draw_image
    import math
    import random

    random.seed(7)

    screen = t.getscreen()
    w = screen.window_width()
    h = screen.window_height()

    def jump(x, y):
        t.penup()
        t.goto(x, y)
        t.pendown()

    def set_color(c):
        t.pencolor(c)
        t.fillcolor(c)

    def lerp(a, b, u):
        return a + (b - a) * u

    def lerp_color(c1, c2, u):
        return (lerp(c1[0], c2[0], u), lerp(c1[1], c2[1], u), lerp(c1[2], c2[2], u))

    def lighten(c, u):
        # blend towards white
        return (lerp(c[0], 1.0, u), lerp(c[1], 1.0, u), lerp(c[2], 1.0, u))

    def darken(c, u):
        # blend towards black
        return (c[0] * (1 - u), c[1] * (1 - u), c[2] * (1 - u))

    def draw_gradient_sky():
        # Vertical gradient stripes
        top = (0.03, 0.03, 0.16)     # deep midnight blue
        mid = (0.10, 0.04, 0.35)     # indigo
        bot = (0.02, 0.02, 0.08)     # almost black
        stripes = 160
        left_x = -w // 2 - 10
        right_x = w // 2 + 10
        y_top = h // 2 + 10
        y_bot = -h // 2 - 10
        total = y_top - y_bot
        t.width(3)
        for i in range(stripes):
            u = i / (stripes - 1)
            # two-stop blend (top->mid->bottom)
            if u < 0.55:
                uu = u / 0.55
                c = lerp_color(top, mid, uu)
            else:
                uu = (u - 0.55) / 0.45
                c = lerp_color(mid, bot, uu)
            set_color(c)
            y = y_top - u * total
            jump(left_x, y)
            t.goto(right_x, y)

    def star_field(n_small=200, n_big=30):
        # sprinkle stars of various colors and glow
        left_x = -w // 2 + 8
        right_x = w // 2 - 8
        bottom_y = -h // 2 + 8
        top_y = h // 2 - 8

        def glow_dot(x, y, r, base, layers=3):
            # draw concentric dots for glow
            for i in range(layers, 0, -1):
                u = (i - 1) / (layers - 1) if layers > 1 else 0
                c = lighten(base, 0.85 * u)
                set_color(c)
                jump(x, y)
                t.dot(max(1, int(r * (0.5 + u))))

        # small stars
        for _ in range(n_small):
            x = random.uniform(left_x, right_x)
            y = random.uniform(bottom_y, top_y)
            r = random.choice([1, 1, 1, 2])
            hue_pick = random.random()
            if hue_pick < 0.75:
                base = (1.0, 1.0, 1.0)
            else:
                base = random.choice([(0.9, 0.95, 1.0), (0.9, 0.9, 1.0), (0.95, 0.9, 1.0), (0.9, 1.0, 0.95)])
            glow_dot(x, y, r, base, layers=random.choice([2, 3]))

        # bright twinklers with cross
        for _ in range(n_big):
            x = random.uniform(left_x, right_x)
            y = random.uniform(bottom_y, top_y)
            col = random.choice([(0.8, 0.95, 1.0), (0.85, 0.9, 1.0), (1.0, 0.95, 0.85)])
            glow_dot(x, y, random.randint(3, 4), col, layers=4)
            # tiny cross
            set_color(darken(col, 0.2))
            t.width(1)
            jump(x - 4, y)
            t.goto(x + 4, y)
            jump(x, y - 4)
            t.goto(x, y + 4)

    def soft_aurora_ring(cx, cy, R=180, thickness=14):
        # halo arc behind the cat's head for a cosmic vibe
        base = (0.25, 0.85, 0.95)
        for i in range(thickness):
            u = i / max(1, thickness - 1)
            c = lerp_color(darken(base, 0.7), base, u)
            set_color(c)
            t.width(3)
            jump(cx - R, cy)
            t.setheading(0)
            # draw a soft bowed arc composed of small segments
            segs = 110
            for j in range(segs + 1):
                v = j / segs
                # a smooth arch using cosine to lift the center
                x = cx + (v - 0.5) * 2 * R
                y = cy + math.cos((v - 0.5) * math.pi) * (R * 0.25) * (1 - u * 0.7)
                t.goto(x, y)

    def stroke_glow_line(p1, p2, glow=(0.1, 0.3, 0.5), core=(0.7, 0.95, 1.0), glow_w=5, core_w=1.8):
        # back glow
        set_color(glow)
        t.width(glow_w)
        jump(*p1)
        t.goto(*p2)
        # core
        set_color(core)
        t.width(core_w)
        jump(*p1)
        t.goto(*p2)

    def draw_polyline(points, glow=(0.07, 0.18, 0.35), core=(0.65, 0.95, 1.0), closed=False):
        if len(points) < 2:
            return
        for i in range(len(points) - 1):
            stroke_glow_line(points[i], points[i + 1], glow=glow, core=core)
        if closed:
            stroke_glow_line(points[-1], points[0], glow=glow, core=core)

    def glow_star_node(p, base=(0.75, 0.95, 1.0), size=4):
        # layered glow dot with small spikes
        x, y = p
        for i in range(4, 0, -1):
            u = i / 4
            c = lerp_color(darken(base, 0.65), base, u)
            set_color(c)
            jump(x, y)
            t.dot(int(size * (0.6 + u)))
        # spikes
        set_color(darken(base, 0.4))
        t.width(1)
        L = size + 1
        jump(x - L, y)
        t.goto(x + L, y)
        jump(x, y - L)
        t.goto(x, y + L)

    def draw_whisker_arc(start, end, bulge=0.2, steps=24, color=(0.75, 0.95, 1.0)):
        # quadratic Bezier-like whisker curve
        (x1, y1), (x2, y2) = start, end
        # control point offset to create a gentle bulge
        mx, my = (x1 + x2) / 2, (y1 + y2) / 2
        dx, dy = x2 - x1, y2 - y1
        nx, ny = -dy, dx
        length = math.hypot(dx, dy)
        if length == 0:
            return
        k = bulge * min(60, max(20, length * 0.15))
        cx, cy = mx + (nx / length) * k, my + (ny / length) * k

        def qlerp(a, b, c, t_):
            # quadratic Bezier interpolation
            xab = lerp(a[0], b[0], t_)
            yab = lerp(a[1], b[1], t_)
            xbc = lerp(b[0], c[0], t_)
            ybc = lerp(b[1], c[1], t_)
            return (lerp(xab, xbc, t_), lerp(yab, ybc, t_))

        # glow stroke
        set_color((0.10, 0.30, 0.45))
        t.width(4)
        jump(x1, y1)
        for i in range(steps + 1):
            u = i / steps
            x, y = qlerp((x1, y1), (cx, cy), (x2, y2), u)
            t.goto(x, y)
        # core
        set_color(color)
        t.width(1.6)
        jump(x1, y1)
        for i in range(steps + 1):
            u = i / steps
            x, y = qlerp((x1, y1), (cx, cy), (x2, y2), u)
            t.goto(x, y)

    def draw_constellation_cat():
        # Scale model to screen
        base_extent = 500  # fits into height roughly
        k = min(w, h) / base_extent

        def P(x, y):
            return (x * k, y * k)

        # Node definitions (front-view seated cat)
        nodes = {
            "LEART": P(-70, 170),
            "LEARB": P(-45, 130),
            "LHS1":  P(-95, 110),
            "LCHEEK": P(-80, 90),
            "CHIN":  P(0, 60),
            "RCHEEK": P(80, 90),
            "RHS1":  P(95, 110),
            "REARB": P(45, 130),
            "REART": P(70, 170),
            "HTOP":  P(0, 155),
            "LSHO":  P(-115, 45),
            "LHIP":  P(-140, -40),
            "LPAW_O": P(-80, -125),
            "LPAW_I": P(-25, -125),
            "RPAW_I": P(25, -125),
            "RPAW_O": P(80, -125),
            "RHIP":  P(140, -40),
            "RSHO":  P(115, 45),
            "TAIL1": P(150, 10),
            "TAIL2": P(120, 70),
            "TAIL3": P(70, 90),
            "TAIL4": P(30, 45),
            "TAIL5": P(60, 5),
            "TAIL6": P(110, -5),
            "NOSE":  P(0, 85),
            "LEYE":  P(-35, 125),
            "REYE":  P(35, 125)
        }

        # Move constellation to center
        # (nodes already around origin; just offset to center on screen center)
        # Glow palette
        glow = (0.07, 0.18, 0.35)
        core = (0.70, 0.95, 1.0)

        # Outline loops
        outline_head = [
            nodes["LEART"], nodes["LEARB"], nodes["LHS1"],
            nodes["LCHEEK"], nodes["CHIN"], nodes["RCHEEK"],
            nodes["RHS1"], nodes["REARB"], nodes["REART"],
            nodes["HTOP"], nodes["LEART"]
        ]
        outline_body = [
            nodes["LCHEEK"], nodes["LSHO"], nodes["LHIP"],
            nodes["LPAW_O"], nodes["LPAW_I"], nodes["RPAW_I"],
            nodes["RPAW_O"], nodes["RHIP"], nodes["RSHO"], nodes["RCHEEK"]
        ]
        tail_path = [
            nodes["RHIP"], nodes["TAIL1"], nodes["TAIL2"],
            nodes["TAIL3"], nodes["TAIL4"], nodes["TAIL5"], nodes["TAIL6"]
        ]

        draw_polyline(outline_head, glow=glow, core=core, closed=False)
        draw_polyline(outline_body, glow=glow, core=core, closed=False)
        draw_polyline(tail_path, glow=glow, core=core, closed=False)

        # Cross links for constellation look
        cross_links = [
            (nodes["HTOP"], nodes["CHIN"]),
            (nodes["LEARB"], nodes["REARB"]),
            (nodes["LSHO"], nodes["RSHO"]),
            (nodes["LPAW_I"], nodes["RPAW_I"]),
            (nodes["LCHEEK"], nodes["RHS1"]),
            (nodes["RCHEEK"], nodes["LHS1"]),
        ]
        for a, b in cross_links:
            stroke_glow_line(a, b, glow=glow, core=darken(core, 0.2), glow_w=4, core_w=1.2)

        # Eyes and nose (glowing nodes)
        glow_star_node(nodes["LEYE"], base=(0.6, 1.0, 0.6), size=6)
        glow_star_node(nodes["REYE"], base=(0.6, 1.0, 0.6), size=6)
        glow_star_node(nodes["NOSE"], base=(1.0, 0.7, 0.85), size=5)

        # Whiskers (curved)
        nx, ny = nodes["NOSE"]
        left_whiskers = [
            ((nx - 6 * k, ny + 2 * k), (-160 * k, 95 * k)),
            ((nx - 6 * k, ny),         (-160 * k, 85 * k)),
            ((nx - 6 * k, ny - 2 * k), (-160 * k, 75 * k)),
        ]
        right_whiskers = [
            ((nx + 6 * k, ny + 2 * k), (160 * k, 95 * k)),
            ((nx + 6 * k, ny),         (160 * k, 85 * k)),
            ((nx + 6 * k, ny - 2 * k), (160 * k, 75 * k)),
        ]
        for s, e in left_whiskers:
            draw_whisker_arc(s, e, bulge=0.18, steps=32, color=(0.75, 0.95, 1.0))
        for s, e in right_whiskers:
            draw_whisker_arc(s, e, bulge=-0.18, steps=32, color=(0.75, 0.95, 1.0))

        # Place glowing nodes at all key points
        key_base = (0.80, 0.95, 1.0)
        for key in nodes:
            # slightly vary size for interest
            size = 5 if key in ("LEART", "REART", "HTOP", "RHIP", "LHIP") else 4
            glow_star_node(nodes[key], base=key_base, size=size)

        # Subtle inner "nebula" swirl inside the cat silhouette
        nebula_center = (0.0, 20.0 * k)
        nebula_colors = [(0.6, 0.4, 0.9), (0.4, 0.7, 1.0), (0.8, 0.6, 1.0)]
        for arm in range(3):
            col = nebula_colors[arm]
            base_angle = arm * 2 * math.pi / 3
            t.width(2)
            for turn in range(2):
                jump(nebula_center[0], nebula_center[1])
                set_color(darken(col, 0.7))
                steps = 140
                R0 = 8 * k + arm * 6 * k
                for i in range(steps):
                    u = i / steps
                    ang = base_angle + 5.2 * u + (0.15 if turn else 0.0)
                    R = R0 + (120 * k) * u
                    x = nebula_center[0] + math.cos(ang) * R
                    y = nebula_center[1] + math.sin(ang) * R * 0.75
                    if i == 0:
                        jump(x, y)
                    else:
                        t.goto(x, y)
                # fade highlight on top
                t.width(1)
                set_color(lighten(col, 0.5))
                jump(nebula_center[0], nebula_center[1])
                for i in range(steps):
                    u = i / steps
                    ang = base_angle + 5.2 * u + (0.15 if turn else 0.0)
                    R = R0 + (120 * k) * u
                    x = nebula_center[0] + math.cos(ang) * R
                    y = nebula_center[1] + math.sin(ang) * R * 0.75
                    if i == 0:
                        jump(x, y)
                    else:
                        t.goto(x, y)

    # Draw the scene
    t.hideturtle()
    t.speed(0)
    t.penup()

    draw_gradient_sky()
    star_field(n_small=210, n_big=28)
    soft_aurora_ring(0, h * 0.1, R=min(w, h) * 0.25, thickness=18)
    draw_constellation_cat()

if __name__ == "__main__":
    t = Turtle()
    t.speed(0)
    screen = t.getscreen()
    screen.tracer(0)

    draw_image(t)

    t.hideturtle()
    screen.update()
    canvas = screen.getcanvas()
    canvas.postscript(file="img.eps")
    img = Image.open("img.eps")
    img.save("img.png")
```

--- New Session ---

System Prompt:
You are an AI coding agent that creates code using the turtle library to draw images in Python.

Fill out the following template:
```python
from turtle import Turtle
from PIL import Image

def draw_image(t: Turtle) -> None:
    """
    YOUR CODE HERE: draw the image here using the turtle library. You may use any helper functions you create.
    """
    pass

if __name__ == "__main__":
    t = Turtle()
    t.speed(0)
    screen = t.getscreen()
    screen.tracer(0)

    draw_image(t)

    t.hideturtle()
    screen.update()
    canvas = screen.getcanvas()
    canvas.postscript(file="img.eps")
    img = Image.open("img.eps")
    img.save("img.png")
```

Only use the turtle library and other native Python libraries, no external libraries besides PIL for saving the image.
Do not modify any section of the template besides the draw_image function.
Create any helper functions needed to draw the image. Make sure the helper functions are defined within the draw_image function.

Your drawings will be scored by two metrics:
    1. Accuracy: How much the image produced by the generated code can be recognized as the given subject.
    2. Novelty: How creative and unique the generated image is.
Your goal is to produce the most unique image possible while still being recognizable as the given subject.
To do so write creative and unique code that produces a unique image. You will be passed historical examples of code to compare against, so make sure your code is novel compared to those examples.

Return your completed code including the template code above within a single code block.

--- New Session ---

System Prompt:
You are an AI coding agent that creates code using the turtle library to draw images in Python.

Fill out the following template:
```python
from turtle import Turtle
from PIL import Image

def draw_image(t: Turtle) -> None:
    """
    YOUR CODE HERE: draw the image here using the turtle library. You may use any helper functions you create.
    """
    pass

if __name__ == "__main__":
    t = Turtle()
    t.speed(0)
    screen = t.getscreen()
    screen.tracer(0)

    draw_image(t)

    t.hideturtle()
    screen.update()
    canvas = screen.getcanvas()
    canvas.postscript(file="img.eps")
    img = Image.open("img.eps")
    img.save("img.png")
```

Only use the turtle library and other native Python libraries, no external libraries besides PIL for saving the image.
Do not modify any section of the template besides the draw_image function.
Create any helper functions needed to draw the image. Make sure the helper functions are defined within the draw_image function.

Your drawings will be scored by two metrics:
    1. Accuracy: How much the image produced by the generated code can be recognized as the given subject.
    2. Novelty: How creative and unique the generated image is.
Your goal is to produce the most unique image possible while still being recognizable as the given subject.
To do so write creative and unique code that produces a unique image. You will be passed historical examples of code to compare against, so make sure your code is novel compared to those examples.

Return your completed code including the template code above within a single code block.

User:
Draw a cat.

Response:
```python
from turtle import Turtle
from PIL import Image

def draw_image(t: Turtle) -> None:
    """
    YOUR CODE HERE: draw the image here using the turtle library. You may use any helper functions you create.
    """
    import math
    import random

    screen = t.getscreen()
    screen.bgcolor("#0b1026")  # deep night sky
    t.penup()
    t.hideturtle()

    # ============ Helper geometry functions ============
    def move_to(x, y):
        t.penup()
        t.goto(x, y)

    def poly(points, fill=None, outline=None, width=1):
        if fill is not None and outline is None:
            t.color(fill)
        elif fill is None and outline is not None:
            t.color(outline)
        elif fill is not None and outline is not None:
            t.color(outline, fill)
        else:
            t.color("#000000")
        t.pensize(width)
        move_to(points[0][0], points[0][1])
        if fill is not None:
            t.begin_fill()
        t.pendown()
        for x, y in points[1:]:
            t.goto(x, y)
        t.goto(points[0][0], points[0][1])
        t.penup()
        if fill is not None:
            t.end_fill()

    def circle_points(cx, cy, r, steps=120):
        return [(cx + r * math.cos(a), cy + r * math.sin(a)) for a in [2 * math.pi * i / steps for i in range(steps)]]

    def ellipse_points(cx, cy, rx, ry, tilt_deg=0, steps=160):
        phi = math.radians(tilt_deg)
        c, s = math.cos(phi), math.sin(phi)
        pts = []
        for i in range(steps):
            a = 2 * math.pi * i / steps
            lx = rx * math.cos(a)
            ly = ry * math.sin(a)
            x = cx + lx * c - ly * s
            y = cy + lx * s + ly * c
            pts.append((x, y))
        return pts

    def inside_circle(x, y, cx, cy, r):
        return (x - cx) ** 2 + (y - cy) ** 2 <= r ** 2

    def inside_ellipse(x, y, cx, cy, rx, ry, tilt_deg=0):
        phi = math.radians(tilt_deg)
        dx, dy = x - cx, y - cy
        c, s = math.cos(phi), math.sin(phi)
        xr = dx * c + dy * s
        yr = -dx * s + dy * c
        return (xr / rx) ** 2 + (yr / ry) ** 2 <= 1.0

    def tri_sign(px, py, ax, ay, bx, by):
        return (px - bx) * (ay - by) - (ax - bx) * (py - by)

    def inside_triangle(x, y, p1, p2, p3):
        b1 = tri_sign(x, y, *p1, *p2) < 0.0
        b2 = tri_sign(x, y, *p2, *p3) < 0.0
        b3 = tri_sign(x, y, *p3, *p1) < 0.0
        return (b1 == b2) and (b2 == b3)

    def line_distance(px, py, ax, ay, bx, by):
        # distance from point P to segment AB
        apx, apy = px - ax, py - ay
        abx, aby = bx - ax, by - ay
        ab2 = abx * abx + aby * aby
        if ab2 == 0:
            return math.hypot(px - ax, py - ay), 0.0
        tproj = (apx * abx + apy * aby) / ab2
        tproj = max(0.0, min(1.0, tproj))
        cx, cy = ax + tproj * abx, ay + tproj * aby
        return math.hypot(px - cx, py - cy), tproj

    def draw_dot(x, y, size, color):
        move_to(x, y)
        t.dot(int(size), color)

    def draw_cross_star(x, y, size, color, secondary=None):
        # simple 8-point star
        t.pensize(max(1, int(size / 5)))
        t.pencolor(color)
        move_to(x, y)
        for ang in [0, 45]:
            t.setheading(ang)
            t.pendown()
            t.forward(size / 2)
            t.penup()
            t.setheading(ang + 180)
            t.pendown()
            t.forward(size / 2)
            t.penup()
        if secondary:
            t.pencolor(secondary)
            t.pensize(1)
            move_to(x, y)
            for ang in [22.5, 67.5]:
                t.setheading(ang)
                t.pendown()
                t.forward(size * 0.35)
                t.penup()
                t.setheading(ang + 180)
                t.pendown()
                t.forward(size * 0.35)
                t.penup()

    # ============ Define cat silhouette primitives ============
    body_cx, body_cy, body_rx, body_ry, body_tilt = 20, -40, 150, 190, -6
    head_cx, head_cy, head_r = -80, 120, 85

    # Ear triangles (stylized)
    left_ear = [(-155, 150), (-108, 195), (-142, 255)]
    right_ear = [(-60, 200), (-8, 152), (-28, 245)]

    # Tail spiral path (archimedean, tapering)
    tail_center = (120, -50)
    T = 5.2
    R0 = 120.0
    k = 17.0
    tail_points = []
    tail_radii = []
    theta = 0.0
    step = 0.055
    while theta <= T:
        r = max(25.0, R0 - k * theta)
        x = tail_center[0] + r * math.cos(theta)
        y = tail_center[1] + r * math.sin(theta)
        # thickness tapers with small gentle ripple
        thick = 22.0 * (1.0 - theta / T) + 6.0 + 2.0 * math.sin(2.0 * theta)
        tail_points.append((x, y))
        tail_radii.append(thick)
        theta += step

    def inside_tail(x, y):
        # Check if point lies within any of the tapered discs along the tail path
        for (px, py), rad in zip(tail_points, tail_radii):
            if (x - px) ** 2 + (y - py) ** 2 <= (rad * 0.9) ** 2:
                return True
        # Additionally, check distance to segments for smoother hull
        for i in range(len(tail_points) - 1):
            ax, ay = tail_points[i]
            bx, by = tail_points[i + 1]
            d, tproj = line_distance(x, y, ax, ay, bx, by)
            # interpolate radius along segment
            rr = tail_radii[i] * (1 - tproj) + tail_radii[i + 1] * tproj
            if d <= rr * 0.85:
                return True
        return False

    def inside_cat(x, y):
        return (
            inside_ellipse(x, y, body_cx, body_cy, body_rx, body_ry, body_tilt)
            or inside_circle(x, y, head_cx, head_cy, head_r)
            or inside_triangle(x, y, *left_ear)
            or inside_triangle(x, y, *right_ear)
            or inside_tail(x, y)
        )

    # ============ Draw silhouette ============
    main_fill = "#1a0f2e"  # deep plum
    inner_fill = "#27143e"  # slightly lighter
    outline_dark = "#3c1e66"
    outline_bright = "#00e6ff"

    # Body
    poly(ellipse_points(body_cx, body_cy, body_rx, body_ry, body_tilt, steps=180), fill=main_fill, outline=main_fill, width=1)
    # Head
    poly(circle_points(head_cx, head_cy, head_r, steps=140), fill=main_fill, outline=main_fill, width=1)
    # Ears
    poly(left_ear, fill=main_fill, outline=main_fill, width=1)
    poly(right_ear, fill=main_fill, outline=main_fill, width=1)
    # Inner ear highlights
    inner_left = [((left_ear[0][0] + left_ear[1][0]) / 2 - 8, (left_ear[0][1] + left_ear[1][1]) / 2 + 8),
                  ((left_ear[1][0] + left_ear[2][0]) / 2 - 5, (left_ear[1][1] + left_ear[2][1]) / 2 + 5),
                  ((left_ear[2][0] + left_ear[0][0]) / 2 + 6, (left_ear[2][1] + left_ear[0][1]) / 2 - 2)]
    inner_right = [((right_ear[0][0] + right_ear[1][0]) / 2 + 6, (right_ear[0][1] + right_ear[1][1]) / 2 + 4),
                   ((right_ear[1][0] + right_ear[2][0]) / 2 + 2, (right_ear[1][1] + right_ear[2][1]) / 2 + 5),
                   ((right_ear[2][0] + right_ear[0][0]) / 2 - 4, (right_ear[2][1] + right_ear[0][1]) / 2 - 6)]
    poly(inner_left, fill="#442161", outline="#442161")
    poly(inner_right, fill="#442161", outline="#442161")

    # Tail drawn as overlapped dots to create smooth taper
    for (x, y), rad in zip(tail_points, tail_radii):
        draw_dot(x, y, rad * 2.0, main_fill)

    # Subtle neon crescent along the back (glow line)
    def draw_back_glow():
        # approximate back curve with sample points along body ellipse upper-right side
        pts = []
        for i in range(30, 85):
            a = 2 * math.pi * i / 180.0
            lx = body_rx * math.cos(a)
            ly = body_ry * math.sin(a)
            phi = math.radians(body_tilt)
            x = body_cx + lx * math.cos(phi) - ly * math.sin(phi)
            y = body_cy + lx * math.sin(phi) + ly * math.cos(phi)
            pts.append((x, y))
        # draw a double-stroke glow
        t.pensize(10)
        t.pencolor("#2a1351")
        move_to(pts[0][0], pts[0][1])
        t.pendown()
        for x, y in pts[1:]:
            t.goto(x, y)
        t.penup()
        t.pensize(4)
        t.pencolor("#8a5dff")
        move_to(pts[0][0], pts[0][1])
        t.pendown()
        for x, y in pts[1:]:
            t.goto(x, y)
        t.penup()

    draw_back_glow()

    # ============ Face details ============
    def draw_eye(cx, cy, w, h, iris_color="#9bff8f", lid_color="#c0ffe6"):
        # Almond shape from two arcs
        steps = 40
        upper = []
        lower = []
        for i in range(steps + 1):
            u = i / steps
            x = cx - w / 2 + w * u
            y = cy + h * math.sin(math.pi * u)
            upper.append((x, y))
        for i in range(steps + 1):
            u = i / steps
            x = cx + w / 2 - w * u
            y = cy - h * math.sin(math.pi * u)
            lower.append((x, y))
        eye_shape = upper + lower
        poly(eye_shape, fill=lid_color, outline="#e0fff5", width=2)

        # Iris
        poly(circle_points(cx, cy, min(w, h) * 0.32, steps=40), fill=iris_color, outline=iris_color)
        # Pupil (vertical ellipse)
        pupil_pts = ellipse_points(cx, cy, min(w, h) * 0.08, h * 0.5, tilt_deg=0, steps=50)
        poly(pupil_pts, fill="#0d1415", outline="#0d1415")
        # Shine
        draw_dot(cx - w * 0.12, cy + h * 0.22, 6, "#ffffff")
        draw_dot(cx - w * 0.08, cy + h * 0.28, 3, "#ffeecc")

    # Eyes positions
    draw_eye(-115, 120, 60, 32)
    draw_eye(-55, 120, 60, 32)

    # Nose
    nose_w = 18
    nose = [(-80 - nose_w / 2, 98), (-80 + nose_w / 2, 98), (-80, 88)]
    poly(nose, fill="#ff9aa9", outline="#ffc4cc", width=2)

    # Mouth - two small curves
    def curve_mouth(x0, y0, x1, y1, ctrl_dx, ctrl_dy, color="#ffeef5", width=2, steps=25):
        t.pensize(width)
        t.pencolor(color)
        move_to(x0, y0)
        t.pendown()
        for i in range(steps + 1):
            u = i / steps
            # Quadratic Bezier
            cx = x0 + ctrl_dx
            cy = y0 + ctrl_dy
            x = (1 - u) ** 2 * x0 + 2 * (1 - u) * u * cx + u ** 2 * x1
            y = (1 - u) ** 2 * y0 + 2 * (1 - u) * u * cy + u ** 2 * y1
            t.goto(x, y)
        t.penup()

    curve_mouth(-80, 88, -95, 80, -10, -8)
    curve_mouth(-80, 88, -65, 80, 10, -8)

    # Whiskers - comet-like dotted curves
    def dotted_whisker(x0, y0, dx, dy, bend, count=10, col="#a7ffe9"):
        for i in range(count):
            u = i / (count - 1)
            x = x0 + dx * u
            y = y0 + dy * u + bend * math.sin(math.pi * u)
            size = 5 - 2.2 * u
            draw_dot(x, y, size, col)

    # Left whiskers
    dotted_whisker(-95, 96, -110, 10, -12, count=8)
    dotted_whisker(-95, 100, -115, -5, -10, count=9, col="#d3fff6")
    dotted_whisker(-95, 104, -100, 25, -14, count=8, col="#7affef")
    # Right whiskers
    dotted_whisker(-65, 96, 110, 10, 12, count=8)
    dotted_whisker(-65, 100, 115, -5, 10, count=9, col="#d3fff6")
    dotted_whisker(-65, 104, 100, 25, 14, count=8, col="#7affef")

    # ============ Constellations and cosmic fill ============

    # Scatter tiny stars within silhouette
    star_colors = ["#a0eaff", "#fff9b0", "#ffd1ff", "#7fffd4", "#c4b5ff"]
    accent_colors = ["#00f0ff", "#ff6bd6", "#b19eff"]
    random.seed(8)

    # Spiral glow in the belly
    def belly_spiral():
        cx, cy = -10, -20
        a = 2.0
        b = 0.22
        turns = 6.5
        steps = 220
        for i in range(steps):
            th = turns * 2 * math.pi * (i / steps)
            r = a * math.exp(b * th)
            x = cx + r * math.cos(th)
            y = cy + r * math.sin(th)
            if inside_cat(x, y):
                hue = i / steps
                # simple 2-color interpolation
                if hue < 0.5:
                    col = "#5bd3ff"
                else:
                    col = "#ff77e1"
                draw_dot(x, y, 3.5 - 1.8 * (i / steps), col)

    belly_spiral()

    # Star sprinkle
    minx, maxx = -260, 280
    miny, maxy = -240, 270
    for _ in range(420):
        x = random.uniform(minx, maxx)
        y = random.uniform(miny, maxy)
        if inside_cat(x, y):
            if random.random() < 0.08:
                c1 = random.choice(star_colors)
                c2 = random.choice(accent_colors)
                draw_cross_star(x, y, random.uniform(6, 10), c1, secondary=c2)
            else:
                draw_dot(x, y, random.uniform(2.2, 3.8), random.choice(star_colors))

    # Draw small constellations inside the silhouette
    def draw_constellation(center, radius, nstars=5):
        pts = []
        for _ in range(nstars * 3):
            ang = random.uniform(0, 2 * math.pi)
            r = radius * math.sqrt(random.random())
            x = center[0] + r * math.cos(ang)
            y = center[1] + r * math.sin(ang)
            if inside_cat(x, y):
                pts.append((x, y))
            if len(pts) >= nstars:
                break
        if len(pts) < 2:
            return
        # connect in nearest-neighbor order from first
        used = [0]
        remaining = list(range(1, len(pts)))
        order = [0]
        while remaining:
            last = order[-1]
            # find nearest
            nearest = min(remaining, key=lambda j: (pts[j][0] - pts[last][0]) ** 2 + (pts[j][1] - pts[last][1]) ** 2)
            order.append(nearest)
            remaining.remove(nearest)
        # draw
        t.pensize(2)
        t.pencolor(random.choice(accent_colors))
        move_to(pts[order[0]][0], pts[order[0]][1])
        t.pendown()
        for idx in order[1:]:
            t.goto(pts[idx][0], pts[idx][1])
        t.penup()
        # stars on nodes
        for (x, y) in pts:
            draw_dot(x, y, 4, "#ffffff")
            if random.random() < 0.4:
                draw_cross_star(x, y, 6, random.choice(star_colors))

    # Place a handful of constellations across the cat
    const_centers = [
        (-40, 20),
        (40, -60),
        (-80, 160),
        (80, 40),
        (-10, -140),
        (120, -40),
    ]
    for c in const_centers:
        draw_constellation(c, radius=random.uniform(35, 60), nstars=random.randint(4, 7))

    # Tail neon edge accent
    def tail_glow():
        t.pensize(7)
        t.pencolor("#2a1351")
        move_to(tail_points[0][0], tail_points[0][1])
        t.pendown()
        for x, y in tail_points[1:]:
            t.goto(x, y)
        t.penup()
        t.pensize(3)
        t.pencolor("#76fff7")
        move_to(tail_points[0][0], tail_points[0][1])
        t.pendown()
        for x, y in tail_points[1:]:
            t.goto(x, y)
        t.penup()

    tail_glow()

    # Subtle head outline for clarity
    def head_outline():
        t.pensize(4)
        t.pencolor(outline_bright)
        pts = circle_points(head_cx, head_cy, head_r, steps=120)
        move_to(pts[0][0], pts[0][1])
        t.pendown()
        for x, y in pts[1:]:
            t.goto(x, y)
        t.penup()

    head_outline()

if __name__ == "__main__":
    t = Turtle()
    t.speed(0)
    screen = t.getscreen()
    screen.tracer(0)

    draw_image(t)

    t.hideturtle()
    screen.update()
    canvas = screen.getcanvas()
    canvas.postscript(file="img.eps")
    img = Image.open("img.eps")
    img.save("img.png")
```

--- New Session ---

System Prompt:
You are an AI coding agent that creates code using the turtle library to draw images in Python.

Fill out the following template:
```python
from turtle import Turtle
from PIL import Image

def draw_image(t: Turtle) -> None:
    """
    YOUR CODE HERE: draw the image here using the turtle library. You may use any helper functions you create.
    """
    pass

if __name__ == "__main__":
    t = Turtle()
    t.speed(0)
    screen = t.getscreen()
    screen.tracer(0)

    draw_image(t)

    t.hideturtle()
    screen.update()
    canvas = screen.getcanvas()
    canvas.postscript(file="img.eps")
    img = Image.open("img.eps")
    img.save("img.png")
```

Only use the turtle library and other native Python libraries, no external libraries besides PIL for saving the image.
Do not modify any section of the template besides the draw_image function.
Create any helper functions needed to draw the image. Make sure the helper functions are defined within the draw_image function.

Your drawings will be scored by two metrics:
    1. Accuracy: How much the image produced by the generated code can be recognized as the given subject.
    2. Novelty: How creative and unique the generated image is.
Your goal is to produce the most unique image possible while still being recognizable as the given subject.
To do so write creative and unique code that produces a unique image. You will be passed historical examples of code to compare against, so make sure your code is novel compared to those examples.

Return your completed code including the template code above within a single code block.

User:
Draw a cat.

Response:
```python
from turtle import Turtle
from PIL import Image
import math
import random

def draw_image(t: Turtle) -> None:
    """
    Draw a stylized, colorful cat using the turtle library.
    The drawing includes a decorative background, a patchwork body,
    expressive eyes, a heart-shaped nose, whiskers, a striped tail,
    and a little collar with a bell.
    """
    # Helper functions
    def move(x, y):
        t.penup()
        t.goto(x, y)
        t.pendown()

    def circle_center(x, y, r, fillcolor=None, pencolor=None, pensz=1):
        """
        Draw a circle with center at (x, y) and radius r.
        """
        if pencolor:
            t.pencolor(pencolor)
        t.pensize(pensz)
        if fillcolor:
            t.fillcolor(fillcolor)
            t.begin_fill()
        move(x, y - r)
        t.setheading(0)
        t.circle(r)
        if fillcolor:
            t.end_fill()

    def semi_circle_center(x, y, r, extent=180, fillcolor=None, pencolor=None, pensz=1, orientation=1):
        """
        Draw a semicircle (or arc) centered at (x, y) with radius r.
        orientation=1 draws the arc from left to right (top half); -1 flips it.
        extent in degrees.
        """
        if pencolor:
            t.pencolor(pencolor)
        t.pensize(pensz)
        if fillcolor:
            t.fillcolor(fillcolor)
            t.begin_fill()
        # place turtle at leftmost point if drawing top arc; adjust by orientation
        angle = 90 * orientation
        move(x + r * math.cos(math.radians(angle)), y + r * math.sin(math.radians(angle)))
        t.setheading(180 * (1 - orientation) / 2)  # roughly point tangentially
        t.circle(r * orientation, extent)
        if fillcolor:
            t.end_fill()

    def polygon(points, fillcolor=None, pencolor=None, pensz=1):
        if pencolor:
            t.pencolor(pencolor)
        t.pensize(pensz)
        if fillcolor:
            t.fillcolor(fillcolor)
            t.begin_fill()
        move(points[0][0], points[0][1])
        for (px, py) in points[1:]:
            t.goto(px, py)
        t.goto(points[0][0], points[0][1])
        if fillcolor:
            t.end_fill()

    def draw_background():
        # soft circle background behind the cat
        circle_center(0, 20, 360, fillcolor="#EAF6FF", pencolor="#EAF6FF")
        # scatter some stylized stars
        random.seed(42)
        star_colors = ["#FFF9C4", "#FFE0B2", "#FCE4EC", "#E1F5FE"]
        for i in range(20):
            sx = random.randint(-380, 380)
            sy = random.randint(-220, 320)
            col = random.choice(star_colors)
            t.pencolor(col)
            t.fillcolor(col)
            move(sx, sy)
            t.begin_fill()
            for _ in range(4):
                t.forward(6)
                t.right(90)
            t.end_fill()

    def draw_patch(x, y, w, h, angle=0, fill="#FFD59E"):
        # draw an oriented rectangle patch as polygon for patchwork
        hw = w / 2
        hh = h / 2
        # corners before rotation
        corners = [(-hw, -hh), (hw, -hh), (hw, hh), (-hw, hh)]
        pts = []
        for cx, cy in corners:
            rx = cx * math.cos(math.radians(angle)) - cy * math.sin(math.radians(angle)) + x
            ry = cx * math.sin(math.radians(angle)) + cy * math.cos(math.radians(angle)) + y
            pts.append((rx, ry))
        polygon(pts, fillcolor=fill, pencolor="#8C5A30", pensz=2)

    def draw_body():
        # Main rounded body (big circle)
        circle_center(0, -40, 140, fillcolor="#F6D6A8", pencolor="#8C5A30", pensz=3)

        # Patchwork: several patches with different patterns
        patches = [
            (-40, -20, 80, 60, -20, "#FFB6B9"),
            (50, -10, 90, 70, 15, "#C1E1C1"),
            (-10, -80, 120, 50, 10, "#FFD59E"),
            (30, -70, 60, 50, -25, "#E1F5FE"),
        ]
        for x, y, w, h, ang, col in patches:
            draw_patch(x, y, w, h, ang, col)
            # add polka dots inside patch
            for dx in range(3):
                for dy in range(2):
                    px = x + (dx - 1) * (w / 6) + random.uniform(-6, 6)
                    py = y + (dy - 0.5) * (h / 4) + random.uniform(-6, 6)
                    circle_center(px, py, 6, fillcolor="#FFFFFF", pencolor="#FFFFFF")

        # stripes on body
        t.pencolor("#D2945B")
        t.pensize(4)
        for i in range(5):
            move(-100 + i * 40, -20 + 12 * math.sin(i))
            t.setheading(320 + i * 5)
            t.circle(60, 40)

    def draw_head():
        # Head circle
        circle_center(0, 80, 80, fillcolor="#F7E0C6", pencolor="#8C5A30", pensz=3)

        # Ears - outer
        left_ear = [(-60, 150), (-20, 190), (-10, 150)]
        right_ear = [(60, 150), (20, 190), (10, 150)]
        polygon(left_ear, fillcolor="#F6D6A8", pencolor="#8C5A30", pensz=3)
        polygon(right_ear, fillcolor="#F6D6A8", pencolor="#8C5A30", pensz=3)
        # ear inner
        polygon([(-46, 152), (-22, 178), (-16, 153)], fillcolor="#FFD2E0", pencolor="#C77B8D", pensz=2)
        polygon([(46, 152), (22, 178), (16, 153)], fillcolor="#FFD2E0", pencolor="#C77B8D", pensz=2)

        # forehead stripe
        t.pencolor("#D2945B")
        t.pensize(3)
        move(-20, 125)
        t.setheading(60)
        t.circle(30, 120)

    def draw_eye(cx, cy, size=22, iris="#5DA1FF"):
        # white
        circle_center(cx, cy, size, fillcolor="#FFFFFF", pencolor="#6B6B6B", pensz=2)
        # iris
        circle_center(cx, cy + 3, size * 0.55, fillcolor=iris, pencolor=iris)
        # pupil
        circle_center(cx, cy + 5, size * 0.2, fillcolor="#000000", pencolor="#000000")
        # sparkle
        circle_center(cx + 6, cy + 11, size * 0.12, fillcolor="#FFFFFF", pencolor="#FFFFFF")

    def draw_eyes_and_nose():
        # Eyes
        draw_eye(-30, 95, size=26, iris="#6ABED6")
        draw_eye(30, 95, size=26, iris="#6ABED6")

        # Nose: stylized heart-like (two small semicircles + triangle)
        # left bump
        circle_center(-8, 69, 6, fillcolor="#FF8FA3", pencolor="#C85B6E", pensz=2)
        circle_center(8, 69, 6, fillcolor="#FF8FA3", pencolor="#C85B6E", pensz=2)
        # lower triangle
        polygon([( -8, 64 ), (8, 64), (0, 54)], fillcolor="#FF8FA3", pencolor="#C85B6E", pensz=2)

        # little mouth
        t.pencolor("#C85B6E")
        t.pensize(2)
        move(0, 54)
        t.setheading(-60)
        t.circle(12, 120)

    def draw_whiskers():
        t.pencolor("#6B6B6B")
        t.pensize(2)
        wlen = 80
        # three whiskers each side, slight curves using circle arcs
        for i, offset in enumerate([0, -8, 8]):
            # right side
            move(18, 66 + offset)
            t.setheading(350 - i * 6)
            t.circle(-60 - i * 6, 45)
            # left side
            move(-18, 66 + offset)
            t.setheading(190 + i * 6)
            t.circle(60 + i * 6, 45)

    def draw_paws():
        # front paws (two small overlapping circles at bottom of body)
        circle_center(-45, -160, 28, fillcolor="#F6D6A8", pencolor="#8C5A30", pensz=3)
        circle_center(45, -160, 28, fillcolor="#F6D6A8", pencolor="#8C5A30", pensz=3)
        # toe lines
        t.pencolor("#8C5A30")
        t.pensize(2)
        for px in (-45, 45):
            for i in range(3):
                move(px - 10 + i * 10, -160 + 8)
                t.setheading(80)
                t.forward(8)

    def draw_tail():
        # wavy tail made from sequential arcs with alternating colors (striped tail)
        base_x, base_y = 120, -10
        t.pensize(8)
        tail_colors = ["#F6D6A8", "#D2945B"]
        heading = 80
        x, y = base_x, base_y
        seg = 12
        length = 30
        for i in range(seg):
            col = tail_colors[i % 2]
            t.pencolor(col)
            move(x, y)
            t.setheading(heading + (i % 2) * 25)
            # draw a small curve by using circle with small radius and extent
            r = 30 + i * 3
            extent = 40
            if i % 2 == 0:
                t.circle(-r, extent)
            else:
                t.circle(r, extent)
            # update x,y to tail tip approx (move forward along heading)
            heading += (-1) ** i * 25
            x += math.cos(math.radians(heading)) * (length + i * 1.5)
            y += math.sin(math.radians(heading)) * (length + i * 1.5)

        # tip
        circle_center(x, y, 12, fillcolor="#F6D6A8", pencolor="#8C5A30", pensz=2)

    def draw_collar():
        # collar as half-ring under chin
        t.pensize(6)
        t.pencolor("#D32F2F")
        move(-55, 60)
        t.setheading(0)
        t.circle(55, 120)
        # bell
        circle_center(0, 38, 12, fillcolor="#FFD54F", pencolor="#B58210", pensz=2)
        # clapper
        circle_center(0, 30, 3, fillcolor="#B58210", pencolor="#B58210")
        # highlight on bell
        circle_center(6, 46, 3, fillcolor="#FFF9C4", pencolor="#FFF9C4")

    # Start drawing in layers
    draw_background()
    draw_body()
    draw_tail()
    draw_head()
    draw_eyes_and_nose()
    draw_whiskers()
    draw_paws()
    draw_collar()

if __name__ == "__main__":
    t = Turtle()
    t.speed(0)
    screen = t.getscreen()
    screen.tracer(0)

    draw_image(t)

    t.hideturtle()
    screen.update()
    canvas = screen.getcanvas()
    canvas.postscript(file="img.eps")
    img = Image.open("img.eps")
    img.save("img.png")
```

